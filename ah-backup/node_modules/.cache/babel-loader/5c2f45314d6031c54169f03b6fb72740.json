{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePrefix = exports.inlineStyleExporter = exports.createInlineStyleExportObject = exports.getInlineStyles = exports.customStyleFns = exports.createCustomStyles = exports.mapSelectedCharacters = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _draftJs = require('draft-js');\n\nvar _immutable = require('immutable');\n\nvar _lodash = require('lodash.camelcase');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require('lodash.snakecase');\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_PREFIX = 'CUSTOM_'; // This functionality has been taken from draft-js and modified for re-usability purposes.\n// Maps over the selected characters, and applies a function to each character.\n// Characters are of type CharacterMetadata.\n\nvar mapSelectedCharacters = exports.mapSelectedCharacters = function mapSelectedCharacters(callback) {\n  return function (editorState) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n    var blockMap = contentState.getBlockMap();\n    var startKey = selectionState.getStartKey();\n    var startOffset = selectionState.getStartOffset();\n    var endKey = selectionState.getEndKey();\n    var endOffset = selectionState.getEndOffset();\n    var newBlocks = blockMap.skipUntil(function (_, k) {\n      return k === startKey;\n    }).takeUntil(function (_, k) {\n      return k === endKey;\n    }).concat((0, _immutable.Map)([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {\n      var sliceStart = void 0;\n      var sliceEnd = void 0; // sliceStart -> where the selection starts\n      // endSlice -> Where the selection ends\n      // Only 1 block selected\n\n      if (startKey === endKey) {\n        sliceStart = startOffset;\n        sliceEnd = endOffset; // Gets the selected characters of the block when multiple blocks are selected.\n      } else {\n        sliceStart = blockKey === startKey ? startOffset : 0;\n        sliceEnd = blockKey === endKey ? endOffset : block.getLength();\n      } // Get the characters of the current block\n\n\n      var chars = block.getCharacterList();\n      var current = void 0;\n\n      while (sliceStart < sliceEnd) {\n        current = chars.get(sliceStart);\n        var newChar = callback(current);\n        chars = chars.set(sliceStart, newChar);\n        sliceStart++;\n      }\n\n      return block.set('characterList', chars);\n    });\n    return contentState.merge({\n      blockMap: blockMap.merge(newBlocks),\n      selectionBefore: selectionState,\n      selectionAfter: selectionState\n    });\n  };\n};\n\nvar getContentStateWithoutStyle = function getContentStateWithoutStyle(prefix, editorState) {\n  return mapSelectedCharacters(filterDynamicStyle(prefix))(editorState);\n};\n\nvar filterDynamicStyle = function filterDynamicStyle(prefix) {\n  return function (char) {\n    var charStyles = char.get('style');\n    var filteredStyles = charStyles.filter(function (style) {\n      return !style.startsWith(prefix);\n    });\n    return char.set('style', filteredStyles);\n  };\n};\n\nvar addStyle = function addStyle(prefix) {\n  return function (editorState, value) {\n    var style = prefix + value;\n\n    var newContentState = _draftJs.Modifier.applyInlineStyle(getContentStateWithoutStyle(prefix, editorState), editorState.getSelection(), style);\n\n    var isCollapsed = editorState.getSelection().isCollapsed();\n\n    if (isCollapsed) {\n      return addInlineStyleOverride(prefix, style, editorState);\n    }\n\n    return _draftJs.EditorState.push(editorState, newContentState, 'change-inline-style');\n  };\n};\n\nvar removeStyle = function removeStyle(prefix) {\n  return function (editorState) {\n    return _draftJs.EditorState.push(editorState, getContentStateWithoutStyle(prefix, editorState), 'change-inline-style');\n  };\n};\n\nvar filterOverrideStyles = function filterOverrideStyles(prefix, styles) {\n  return styles.filter(function (style) {\n    return !style.startsWith(prefix);\n  });\n};\n\nvar addInlineStyleOverride = function addInlineStyleOverride(prefix, style, editorState) {\n  var currentStyle = editorState.getCurrentInlineStyle(); // We remove styles with the prefix from the OrderedSet to avoid having\n  // variants of the same prefix.\n\n  var newStyles = filterOverrideStyles(prefix, currentStyle);\n  return _draftJs.EditorState.setInlineStyleOverride(editorState, newStyles.add(style));\n};\n\nvar toggleInlineStyleOverride = function toggleInlineStyleOverride(prefix, style, editorState) {\n  var currentStyle = editorState.getCurrentInlineStyle(); // We remove styles with the prefix from the OrderedSet to avoid having\n  // variants of the same prefix.\n\n  var newStyles = filterOverrideStyles(prefix, currentStyle);\n  var styleOverride = currentStyle.has(style) ? newStyles.remove(style) : newStyles.add(style);\n  return _draftJs.EditorState.setInlineStyleOverride(editorState, styleOverride);\n};\n\nvar toggleStyle = function toggleStyle(prefix) {\n  return function (editorState, value) {\n    var style = prefix + value;\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var isCollapsed = editorState.getSelection().isCollapsed();\n\n    if (isCollapsed) {\n      return toggleInlineStyleOverride(prefix, style, editorState);\n    }\n\n    if (!currentStyle.has(style)) {\n      return addStyle(prefix)(editorState, value);\n    }\n\n    var editorStateWithoutCustomStyles = _draftJs.EditorState.push(editorState, getContentStateWithoutStyle(prefix, editorState), 'change-inline-style');\n\n    return _draftJs.EditorState.forceSelection(editorStateWithoutCustomStyles, editorState.getSelection());\n  };\n};\n/**\n *  style is an OrderedSet type\n */\n\n\nvar styleFn = function styleFn(prefix, cssProp) {\n  return function (style) {\n    if (!style.size) {\n      return {};\n    }\n\n    var value = style.filter(function (val) {\n      return val.startsWith(prefix);\n    }).first();\n\n    if (value) {\n      var newVal = value.replace(prefix, '');\n      return _defineProperty({}, (0, _lodash2.default)(cssProp), newVal);\n    }\n\n    return {};\n  };\n};\n\nvar currentStyle = function currentStyle(prefix) {\n  return function (editorState) {\n    var selectionStyles = editorState.getCurrentInlineStyle();\n\n    if (!selectionStyles.size) {\n      return '';\n    }\n\n    var result = selectionStyles.filter(function (style) {\n      return style.startsWith(prefix);\n    }).first();\n    return result ? result.replace(prefix, '') : result;\n  };\n};\n\nvar createCustomStyles = exports.createCustomStyles = function createCustomStyles(prefix, conf) {\n  return conf.reduce(function (acc, prop) {\n    var camelCased = (0, _lodash2.default)(prop);\n    var newPrefix = '' + prefix + (0, _lodash4.default)(prop).toUpperCase() + '_';\n\n    var copy = _extends({}, acc);\n\n    copy[camelCased] = {\n      add: addStyle(newPrefix),\n      remove: removeStyle(newPrefix),\n      toggle: toggleStyle(newPrefix),\n      current: currentStyle(newPrefix),\n      styleFn: styleFn(newPrefix, prop)\n    };\n    return copy;\n  }, {});\n}; // customStyleFns\n\n\nvar customStyleFns = exports.customStyleFns = function customStyleFns(fnList) {\n  return function (prefixedStyle) {\n    return fnList.reduce(function (css, fn) {\n      return _extends({}, css, fn(prefixedStyle));\n    }, {});\n  };\n}; // exporter\n\n\nvar getInlineStyles = exports.getInlineStyles = function getInlineStyles(acc, block) {\n  var styleRanges = block.inlineStyleRanges;\n\n  if (styleRanges && styleRanges.length) {\n    var result = styleRanges.map(function (style) {\n      return style.style;\n    });\n    return acc.concat(result);\n  }\n\n  return acc;\n};\n\nvar createInlineStyleExportObject = exports.createInlineStyleExportObject = function createInlineStyleExportObject(prefix, customStyleMap) {\n  return function (acc, style) {\n    // default inline styles\n    if (_draftJs.DefaultDraftInlineStyle[style]) {\n      return Object.assign({}, acc, _defineProperty({}, style, {\n        style: _draftJs.DefaultDraftInlineStyle[style]\n      }));\n    } // custom styleMap styles\n\n\n    if (customStyleMap[style]) {\n      return Object.assign({}, acc, _defineProperty({}, style, {\n        style: customStyleMap[style]\n      }));\n    }\n\n    var regex = new RegExp(prefix + '(.+)_(.+)');\n    var match = style.match(regex); // no matches\n\n    if (!match || !match[1] || !match[2]) {\n      return acc;\n    } // custom styles\n\n\n    var css = match[1].toLowerCase();\n    var value = match[2];\n\n    var inlineStyle = _defineProperty({}, style, {\n      style: _defineProperty({}, (0, _lodash2.default)(css), value)\n    });\n\n    return Object.assign({}, acc, inlineStyle);\n  };\n};\n\nvar inlineStyleExporter = exports.inlineStyleExporter = function inlineStyleExporter(prefix, customStyleMap) {\n  return function (editorState) {\n    var inlineStyles = (0, _draftJs.convertToRaw)(editorState.getCurrentContent()).blocks.reduce(getInlineStyles, []);\n    if (!inlineStyles.length) return {};\n    return inlineStyles.reduce(createInlineStyleExportObject(prefix, customStyleMap), {});\n  };\n};\n\nvar validatePrefix = exports.validatePrefix = function validatePrefix(prefix) {\n  if (typeof prefix !== 'string' || !prefix.length) {\n    return DEFAULT_PREFIX;\n  }\n\n  if (prefix.match(/.+_$/)) {\n    return prefix;\n  }\n\n  return prefix + '_';\n};\n\nexports.default = function (conf) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_PREFIX;\n  var customStyleMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!conf) {\n    console.log('Expecting an array with css properties');\n    return {\n      styles: {}\n    };\n  }\n\n  if (!Array.isArray(conf) || !conf.length) {\n    console.log('createStyles expects first parameter to be an array with css properties');\n    return {\n      styles: {}\n    };\n  }\n\n  var checkedPrefix = validatePrefix(prefix);\n  var styles = createCustomStyles(checkedPrefix, conf);\n  var fnList = Object.keys(styles).map(function (style) {\n    return styles[style].styleFn;\n  });\n  var customStyleFn = customStyleFns(fnList);\n  var exporter = inlineStyleExporter(checkedPrefix, customStyleMap);\n  return {\n    styles: styles,\n    customStyleFn: customStyleFn,\n    exporter: exporter\n  };\n};","map":null,"metadata":{},"sourceType":"script"}