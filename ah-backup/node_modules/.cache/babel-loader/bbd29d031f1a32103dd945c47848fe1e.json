{"ast":null,"code":"import { Map } from 'immutable';\nimport { EditorState, ContentBlock, genKey } from 'draft-js';\n/*\nUsed from [react-rte](https://github.com/brijeshb42/medium-draft)\nby [brijeshb42](https://github.com/brijeshb42/medium-draft)\n*/\n\n/*\nReturns default block-level metadata for various block type. Empty object otherwise.\n*/\n\nexport var getDefaultBlockData = function getDefaultBlockData(blockType) {\n  var initialData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  switch (blockType) {\n    //case Block.TODO: return { checked: false };\n    default:\n      return initialData;\n  }\n};\nexport var getNode = function getNode() {\n  var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n  var t = null;\n\n  if (root.getSelection) {\n    t = root.getSelection();\n  } else if (root.document.getSelection) {\n    t = root.document.getSelection();\n  } else if (root.document.selection) {\n    t = root.document.selection.createRange().text;\n  }\n\n  return t;\n};\n/*\nGet currentBlock in the editorState.\n*/\n\nexport var getCurrentBlock = function getCurrentBlock(editorState) {\n  var selectionState = editorState.getSelection();\n  var contentState = editorState.getCurrentContent();\n  var block = contentState.getBlockForKey(selectionState.getStartKey());\n  return block;\n};\n/*\nAdds a new block (currently replaces an empty block) at the current cursor position\nof the given `newType`.\n*/\n\nexport var addNewBlock = function addNewBlock(editorState) {\n  var newType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"unstyled\";\n  var initialData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var selectionState = editorState.getSelection();\n\n  if (!selectionState.isCollapsed()) {\n    return editorState;\n  }\n\n  var contentState = editorState.getCurrentContent();\n  var key = selectionState.getStartKey();\n  var blockMap = contentState.getBlockMap();\n  var currentBlock = getCurrentBlock(editorState);\n\n  if (!currentBlock) {\n    return editorState;\n  }\n\n  if (currentBlock.getLength() === 0) {\n    if (currentBlock.getType() === newType) {\n      return editorState;\n    }\n\n    var newBlock = currentBlock.merge({\n      type: newType,\n      data: getDefaultBlockData(newType, initialData)\n    });\n    var newContentState = contentState.merge({\n      blockMap: blockMap.set(key, newBlock),\n      selectionAfter: selectionState\n    });\n    return EditorState.push(editorState, newContentState, 'change-block-type');\n  }\n\n  return editorState;\n};\n/*\nChanges the block type of the current block.\n*/\n\nexport var resetBlockWithType = function resetBlockWithType(editorState) {\n  var newType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"unstyled\";\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var contentState = editorState.getCurrentContent();\n  var selectionState = editorState.getSelection();\n  var key = selectionState.getStartKey();\n  var blockMap = contentState.getBlockMap();\n  var block = blockMap.get(key);\n  var text = block.getText();\n  var newBlock = block.merge({\n    text: text,\n    type: newType,\n    data: getDefaultBlockData(newType, data)\n  });\n  var newContentState = contentState.merge({\n    blockMap: blockMap.set(key, newBlock),\n    selectionAfter: selectionState.merge({\n      anchorOffset: 0,\n      focusOffset: 0\n    })\n  });\n  return EditorState.push(editorState, newContentState, 'change-block-type');\n};\n/*\nUpdate block-level metadata of the given `block` to the `newData`/\n*/\n\nexport var updateDataOfBlock = function updateDataOfBlock(editorState, block, newData) {\n  var contentState = editorState.getCurrentContent();\n  var newBlock = block.merge({\n    data: newData\n  });\n  var newContentState = contentState.merge({\n    blockMap: contentState.getBlockMap().set(block.getKey(), newBlock)\n  });\n  return EditorState.push(editorState, newContentState, 'change-block-type'); // return editorState;\n};\nexport var updateTextOfBlock = function updateTextOfBlock(editorState, block, text) {\n  var contentState = editorState.getCurrentContent();\n  var newBlock = block.merge({\n    text: text\n  });\n  var newContentState = contentState.merge({\n    blockMap: contentState.getBlockMap().set(block.getKey(), newBlock)\n  });\n  return EditorState.push(editorState, newContentState, 'replace-text'); // return editorState;\n};\nexport var updateCharacterListOfBlock = function updateCharacterListOfBlock(editorState, block, text, charList) {\n  var contentState = editorState.getCurrentContent();\n  var newBlock = block.merge({\n    text: text,\n    characterList: charList\n  });\n  var newContentState = contentState.merge({\n    blockMap: contentState.getBlockMap().set(block.getKey(), newBlock)\n  });\n  return EditorState.push(editorState, newContentState, 'replace-text'); // return editorState;\n}; // const BEFORE = -1;\n// const AFTER = 1;\n\n/*\nUsed from [react-rte](https://github.com/sstur/react-rte/blob/master/src/lib/insertBlockAfter.js)\nby [sstur](https://github.com/sstur)\n*/\n\nexport var addNewBlockAt = function addNewBlockAt(editorState, pivotBlockKey) {\n  var newBlockType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"unstyled\";\n  var initialData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var content = editorState.getCurrentContent();\n  var blockMap = content.getBlockMap();\n  var block = blockMap.get(pivotBlockKey);\n  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {\n    return v === block;\n  });\n  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {\n    return v === block;\n  }).rest();\n  var newBlockKey = genKey();\n  var newBlock = new ContentBlock({\n    key: newBlockKey,\n    type: newBlockType,\n    text: '',\n    characterList: block.getCharacterList().slice(0, 0),\n    depth: 0,\n    data: Map(getDefaultBlockData(newBlockType, initialData))\n  });\n  var newBlockMap = blocksBefore.concat([[pivotBlockKey, block], [newBlockKey, newBlock]], blocksAfter).toOrderedMap();\n  var selection = editorState.getSelection();\n  var newContent = content.merge({\n    blockMap: newBlockMap,\n    selectionBefore: selection,\n    selectionAfter: selection.merge({\n      anchorKey: newBlockKey,\n      anchorOffset: 0,\n      focusKey: newBlockKey,\n      focusOffset: 0,\n      isBackward: false\n    })\n  });\n  return EditorState.push(editorState, newContent, 'split-block');\n};","map":null,"metadata":{},"sourceType":"module"}